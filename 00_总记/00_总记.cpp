// 00_总记.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"


int main()
{
	return 0;
}

//前言:
//本书讨论的STL是指:标准容器,iostream库的一部分，函数对象和算法
//(其他一些书里面通常是指:algorithm,container,iterator三大部分)
//不包含标准容器适配器(stack、deque、priority_queue，因为没有迭代器支持)，数组(属于C++语言)
//也不包含标准C++库的扩展，比如散列容器、单链表和多种非标准函数对象等。

//术语:
//标准序列容器:vector,string,deque,list
//标准关联容器:set,multiset,map,multimap
//迭代器:输入、输出、前向、双向、随机
//仿函数类:重载了operator()的类  使用仿函数对象的地方大部分可以用真函数替代
//bind1st和bind2nd称为绑定器


//M1:仔细选择容器
// 1.连续内存容器:vector,string,deque，插入删除操作会使迭代器失效 
// 2.基于结点的容器:list,插入删除不会使迭代器失效

//M2:小心对"容器无关代码"的幻想
// STL是建立在泛化的基础上的。数组泛化为容器，参数化了所包含对象的类型。函数泛化为了算法，参数化了所用的迭代器类型。指针泛化为了迭代器，参数化了所指向的对象的类型。

// 不同容器是不同的，优点和缺点大不相同，不要去对它们做包装
// 1.尽量用typedef来代替冗长的container<class> 以及container<class>::iterator代码,使用typedef的好处还有，换另一种容器(以及更换allocator等其他template参数的时候)用的时候很简单
// 2.如果不想对用户暴露所使用容器的类型，则把容器进行封装，把容器类型定义在private域，只提供相应的接口给用户


//M3:使容器里对象的拷贝操作轻量而且正确
// 1.STL里的容器，所有的操作，都是基于拷贝的，插入，读取，删除(导致移动)
// 2.派生类对象拷贝进入基类容器的时候会被砍掉派生类部分
// 3.所以建议装指针来避免这个问题，并且指针的拷贝代价最小，但是指针也会存在诸多不便，所以最好使用智能指针的容器(条款7)

//M4:用empty()代替size()==0
// 1.empty()总是常数时间(因为只检查有没有)
// 2.size()不一定是常数时间(可能需要遍历所有的成员比如list)

//M5:用区间成员函数代替单元素操作
// 1.当要给一个容器完全新的数据集时，assign()应该使用
// 2.所有的目标区间是通过迭代器指定的copy都可以由区间成员函数代替,如insert
// 3.连续内存序列容器：使用区间版本insert相对于单元素insert的好处:
//	(1)减少函数调用开销(2)单元素版本当把一个区间插入到头部的时候，反复移动元素,区间版本计算一次，移动一次就行了
//	(2)单元素版本每次insert可能多次内存分配，区间版本不会。
// 4.对于list来说，反复prev和next赋值也是开销
// 5.代码更少，程序含义更加明确,利于后期的维护
// 6.所有标准容器都支持 
//	(1)区间构造 container::container(begin,end)
//	(2)区间插入 insert(position,begin,end),关联容器:insert(begin,end),使用hash函数判断位置
//	(3)区间删除 erase
//	(4)区间赋值 assign

//M6: C++里的解析方式(函数声明)
// 参看06

//M7: 容器里是指针的时候记得delete
// 参看07

//M8: 容器里不能装智能指针
// 1.因为容易出现拷贝后，原指针就是null的情况，所以禁止使用，但是vs好像可以用。。。
// 比如调用std::sort()，而这些方法的内部，很有可能读取每个元素生成了临时对象，从而排序结束后，直接整个容器都是null了
// 参看07

//M9:不同类型容器的delete
// 参看09

//M11:Allocator的使用

//M12:STL容器的线程安全性
// 1.STL里的容器保证:
	//(1)多个读取者同时读取是安全的(不能有写入这时候)
	//(2)对不同容器同时写是安全的(感觉是废话)
// 2.要实现线程安全,需要做到:
	//(1)每次调用容器的成员函数期间
	//(2)容器返回迭代器的有效生存期内
	//(3)容器的算法执行期间
// 锁定改容器
// 实现方法参见12_01

//M13:尽量使用vector和string来代替动态数组
// 1.new进行分配的话，要确保(1)有delete(2)delete是正确的形式(3)只delete一次(所以通常delete接把指针=null)
// 2.容器还有很多算法
// 3.vector和string也都是兼容以前C风格的遗留代码的，因为是基于数组实现的
// 4.唯一可能的问题是,string采用了引用计数,可以用vector<char>来代替

//M14:使用reverse来避免不必要的重新分配
// 1.size,capacity,resize,reverse的含义
// 虽然vector等可以自动把空间变大，但是每次这样都需要重新移动所有元素，代价其实挺大的
// 2.当确定知道需要多大空间的时候，可以直接先reverse，避免不必要的分配，提高效率

//M16:vector和string传递给传统的C API
// 1.vector因为存储是连续的，所以可以用&v[0]来获取首元素指针之后跟数组一样操作
// 建议前面跟if(!v.empty())避免出现未定义操作
// 2.迭代器不是指针，不能用.begin()代替&v[0],但是可以&*v.begin()，不过没有必要，只是多打字而已
// 2.string不保证连续，所以不能这样，应该使用.c_str()，而且string结尾不保证有null
// 3.vector传给C风格的指针操作后，可以修改内容，但是不能增加或删除，因为不会同时改变vecotr其他成员比如size和capacity
// 5.string要实现从C风格初始化的话，必须先vector<char>,在把迭代器给string(x.begin(),x.end())这样来实现
// 事实上这个方法适用于所有的容器

//M17:使用交换技巧来修正过剩容量
// 1.vector在内容变少的时候，不会动态修正其容量(capacity)，reverse也不能变小
// 2.通过vector<T>(v).swap(v)来拷贝一次使其变小
// 临时对象对原有vector进行拷贝的时候，只会拷贝元素需要的内存，不会拷贝多的
// 3.string也是类似的

//M18:避免使用vector<bool>
// 1.vector<bool>里面装的是bit，故不能用C风格的方法来读取元素 bool *p = &v[0]
// 2.vector<bool>替代可以使用deque，但是内存不连续，也不能用C风格，但是装的是真正的bool
// 3.或者使用bitset

//M19:相等和等价的区别
// 1.set的成员函数insert是利用等价来判断的，
// 基于operator<,而标准库的find算法，是利用相等判断的，基于operator==
// operator<判断等价: !(a<b)&&!(b<a)，等价是在一个有序区间中判断对象的相对位置(通常用于和排序有关的地方如关联容器里面)
// operator==判断相等: a==b
// 2.使用的时候优先使用成员函数的版本，才能保持统一
// 3.关联容器之所有使用等价而不是相等，原因在于关联容器本身还要做排序
// 因此就需要oeprator<,之后其他的也可以利用这个oeprator<来判断，更省事

//M20:为元素是指针的关联容器指定比较类型
// 除了用于指针的时候，还可以用于所有需要按照指定属性进行排序的地方，比如set里面装Person类
// 可以按照ID进行排序
// 参见20_01

//M21:为关联容器自己指定比较器的时候不能在相等的时候返回true
// 1.就是不能用<=来进行比较，必须强＜才行，否则会出问题
// 比如set容器，我们指定一个operator()的行为是小于等于返回true的比较器，那么当插入两个10的时候，比较等价性
// !(10<=10) && !(10<=10) -> false  判断为不等价就会继续插入，将会导致未定义的行为。
// 正确的做法: !(10<10) && !(10<10) ->true 判断为等价就不会继续插入
// 2.针对的是关联容器(需要排序)
// 3.升序降序的时候，改写仿函数的operator()的时候，不要简单的把 return val1<val2 改成 !(val1<val2).
// 4.就是是针对multimap和multiset也不能这么做，比如当使用equal_range的时候，是指示等价的区间
// 这时如果你插入两个10，那么因为less_equal判断为不等价，则不会反回两个10都在其中的范围就错了。

//M22:set和map的键（影响排序的值）不允许被改变
// 1.参见22_01

//M23:考虑用有序vector替代关联容器
// 0.如果查找速度非常重要，可以使用非标准的散列容器
// 1.标准关联容器的实现是使用平衡二叉树(对插入、删除和查找都进行了混合优化)，每个元素都会有其父指针及兄弟指针，
// 因此最少一个元素12个字节，而vector则不用(结构变大带来的问题是页面和高速缓存方面的)，但是得自己忍受排序的价值，排序的时候又要全部拷贝
// 但是排序完成后，查找速度更快，所以当你需要的结构插入和删除比较少的时候，使用有序vector是不错的选择。
// 2.只有有序的容器才能使用binary_search、lower_bound、equal_range等查找算法，所以只要vector有序也可以用
// 3.具体的实现则是vector里面存储pair结构，自行实现排序的算法(针对pair)
// 4.vector的插入和删除很昂贵，所以只有当数据结构使用的时候查找不和删除和插入混合时，使用vector代替关联容器才有意义。

//M24:map容器的下标操作和insert操作
// 1.结论:当添加的时候，应该用insert，当更新的时候，用[]
// 2.添加的时候若用[],会先创建对象(默认构造函数)再去赋值，所以不如insert
// 3.而更新的时候，insert必须构建对象，且不美观。所以建议用[]

//M25:熟悉散列容器，unordered_set
// 1.可以自己改写hash函数，比较是通过相等而不是等价，因为不需要排序了
// 2.但是仍然不是按照插入顺序来排序的，如果需要这种需求的话，自己改写一个vector
// 然后insert的时候，判断是否已经存在，不存在再插入便达到了需求

//M26:尽量使用iterator而不是const_iterator或者reverse_iterator
// 1.不存在从const_iterator到iterator之间的隐式转换，反着可以，所以背后的其实还是那句话
// const的可以操作非const的，非const的不能操作const的
// 2.涉及到插入和删除的时候，必须用Iterator，所以尽量都用Iterator
// 参见26_01


//M27:使用distance和advance实现去掉const_iterator的const
// 1.不能直接const_cast,本质上const_iterator和iterator是两个完全不同的类型，不是只加了const修饰符
// 2.但是vector和string内部就是typedef const T* vector<T>::iterator,所以可以直接转型，亲测VS不行
// 3.转型办法参加26_01

//M28:通过reverse_iterator转换成Iterator
// 1.reverse_iterator的insert可以直接.base来实现
// 2.reverse_iterator.base()，返回指向其前一个元素(逆序)的iterator(正序的下一个元素)
// 3.插入操作就是将新元素插入到指定迭代器位置，然后将原先的迭代器指向的元素移到遍历过程的下一个
// (这里下一个是看正序还是反序而定的)

//M29:itreambuf_iterator
// 1.istream_iterator不能读入空格这些空白字符，istreambuf_iterator可以

//M30:确保容器的容量足够大小
// 1.back_inserter等inserter的使用可以确保不会出现未定义的操作，参见30_01
// 2.连续容器如vector在调用之前，最好先reverse
// （reverse只是容量变大,是原始比特，但是size没变，所以还是必须inserter，而不能直接更改那个位置），但是还是得忍受移动的代价
// 3.任何时候，容器需要增加大小（size）的时候，一定要用inserter

 //M31:选择合适的sort
// 1.vector,deque,string,数组为第一类，list第二类
// 2.对于第一类，完全排序用sort或者stable_sort,只排序前N个用partial_sort,不关心前N个顺序
// 用nth_element,只需要按条件分为两部分但并不排序，用Partition或者stable_partition
// 3.list中sort可代替stable_sort
// 4.性能: partion>stable_partition>nth_element>partial_sort>sort>stable_sort

//M32:std:remove一定要和成员的erase联合使用
// 1.std::remove并不删除元素，只是将不删除的元素移到开始，返回第一个需要删除的元素的iterator，因此要接erase
// 而且还不是做的元素间的交换，最终只是保证了前面部分是不需要删除的部分，后面部分可能直接是错位的(因此用了remove一定要erase)。
// 2.list.remove是整合了erase的，可以直接用,这是STL中唯一一个叫remove并且能够删除元素的函数
// 关联容器叫做erase
// 3.类似的还有remove_if和unique

//M33:避免在装有指针的容器使用remove类似的算法
// 1.remove会向前移动元素，就会有覆盖，覆盖了指针的话根本就没法delete了，就内存泄露了
// 2.解决方法是，先用一个for_each，delete掉相应的内存，或者使用Partition
// 其实就是正常解决方法
// 3.如果用的是智能指针的话，就可以直接remove_erase了


//M35:为STL库实现忽略大小写的比较
// 参见35_01

//M36:copy_if在VS里面已经实现了


//M38:把仿函数类设计为用于值传递
// 1.默认仿函数对象的传递都是基于值传递的。
// 2.尽量就使用值传递。。(没咋看懂)
// 3.因为是值传递，尽量设计可以拷贝的对象(不要有多态性质)

//M39:用纯函数做判断式
// 1.判断式就是返回bool的函数
// 2.纯函数是"返回值只依赖于函数参数"的函数,比如f(x,y)只依赖于x,y而不依赖于其他变量比如自己的成员变量,
// 也就是说每一次不同调用，只要参数相同结果就相同
// 3.判断式类是它的operator()是一个判断式，任何STL需要判断式的地方都可以传递判断式对象。
// 4.因为仿函数是值传递的，因此每次拷贝后是不同的对象，所以一定要用纯函数做判断式，不然可能会出错。
// 这样一来，通常operator()都需要加上const使之成为const成员函数

//M40:使仿函数类可适配
// 参见代码40_01

//M41:ptr_fun,mem_fun,mem_fun_ref
// 参见代码41_01

//M42:不要改变less<T>的行为(调用operator<)
// 参见代码42_01

//中间算法的一部分，有些写在了CPlusPlusPrimer工程里面，而仿函数类因为有lambda表达式不需要了


//M43：尽量用算法代替手写循环
// 1.效率(开发算法的人几乎总是比你更能写出高效率的算法)，可维护性,代码清晰度，正确性，写循环很容易出错,
// 2.transform 针对一个区间的元素进行某种操作，转换到另一个区间

//M44:尽量用成员函数替代同名的std::algorithm
// 1.成员函数版本更快(比如set，调用.find 对数时间,std::find()线性时间)
// 2.与容器结合的更好
// 3.判断元素相同，成员函数使用的是等价而不是相等。
// 4.list的成员函数的行为和std::版本通常都不一样

//M45:find,count,binary_search,lower_bound,upper_bound,equal_range的区别
// 1.无序区间用find和count，有序用剩下的
// 2.find和count都可以用来检测存在与否，但是find()找到第一个就停了，因此效率更好。
// 3.find()返回迭代器可以继续操作，count不能
// 4.count和find是线性时间，而其他的是对数时间
// 5.count和find用相等搜索，其他的用的等价
// 6.binary_search返回bool,只检查是否存在，equal_range返回一个区间，为找到的元素的区间

//M46:考虑用函数对象替代函数作为算法的参数
// 1.函数对象的operator()可以inline，因此调用没有开销
// 2.直接传递函数的话，其实是传的一个指针参数，再通过指针去找的函数，所以更慢

//M47:避免写太过复杂的算法代码，尽量分步写的简单一些，考虑到后期的维护

//M48:虽然可能一个头文件里面已经包含了另一个头文件，但是尽量还是手动去包含所需要的头文件，这样有利于移植性

//M49:STL库的错误信息可能非常多，但是要学会整理，替换，最后就很简单了

//M50:在const成员函数内部，类的所有非静态成员变量都会成为const的