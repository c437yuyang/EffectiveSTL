// 00_总记.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"


int main()
{
    return 0;
}

//M2:小心对"容器无关代码"的幻想
// 1.尽量用typedef来代替冗长的container<class> 以及container<class>::iterator代码
// 2.如果不想对用户暴露所使用容器的类型，则把容器进行封装，把容器类型定义在private域


//M3:使容器里对象的拷贝操作轻量而且正确
// 1.派生类对象拷贝进入基类容器的时候会被砍掉派生类部分
// 2.所以建议装指针来避免这个问题，并且指针的拷贝代价最小

//M4:用empty()代替size()==0
// 1.empty()总是常数时间(因为只检查有没有)
// 2.size()不一定是常数时间(可能需要遍历所有的成员)

//M5:用区间成员函数代替单元素操作
// 1.当要给一个容器完全新的数据集时，assign()应该使用
// 2.所有的目标区间是通过迭代器指定的copy都可以由区间成员函数代替,如insert
// 3.使用区间成员函数的意义:(1)代码更少，程序含义更加明确(2)对于不同的容器而言，效率提升不一样，
// 对于序列容器，提升很大，就算是list，也能省去很多指针赋值的操作,关联容器选择区间函数也没有损失


//M6: C++里的解析方式(函数声明)
// 参看06

//M7: 容器里是指针的时候记得delete
// 参看07

//M8: 容器里不能装智能指针
// 1.因为容易出现拷贝后，原指针就是null的情况，所以禁止使用，但是vs好像可以用。。。
// 参看07

//M9:不同类型容器的delete
// 参看09

//M14:使用reverse来避免不必要的重新分配
// 1.size,capacity,resize,reverse的含义
// 2.当确定知道需要多大空间的时候，可以直接先reverse，避免不必要的分配，提高效率

//M16:vector和string传递给传统的C API
// 1.vector因为存储是连续的，所以可以用&v[0]来获取首元素指针之后跟数组一样操作
// 2.string不保证连续，所以不能这样，应该使用.c_str()
// 3.vector传给C风格的指针操作后，可以修改内容，但是不能修改器内容的数量